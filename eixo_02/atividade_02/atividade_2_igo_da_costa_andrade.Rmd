---
title: "Atividade 2: Oscilador de Van der Pol"
author: "Igo da Costa Andrade"
date: ""
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## A equação de Van der Pol

A **equação de Van der Pol** é uma equação diferencial não linear de segunda ordem que foi introduzida por Balthasar van der Pol enquanto estudava circuitos elétricos contendo válvulas triodo. Esses circuitos triodos apresentam um comportamento oscilatório auto-regulador, e a equação de Van der Pol foi usada para descrever o comportamento de osciladores relaxantes.



A equação de Van der Pol tem a forma geral:

\begin{equation}
\ddot{V} - \mu \left(1 - V^2\right)\dot{V} + V = 0 \label{eq:vdp}
\end{equation}
em que:

* $V = V(t)$ é a **diferença de potencial (voltavem)** no circuito no instante de tempo $t$;
* $\dot{V}$ e $\ddot{V}$ representam, respectivamente, a primeira  e a segunda derivadas de $V$ com relação ao tempo $t$;
* $\mu$ é um parâmetro positivo que controla a não linearidade e o grau de amortecimento do sistema.

Escrevamos a equação de Van der Pol como um sistema de equaçãoes diferenciais de primeira ordem introduzindo as variáveis $x = V$ e $y = \dot{V}$, tal que:

\begin{align*}
  \begin{cases}
    \dot{x} = y\\
    \dot{y} = -x + \mu \left(1 - x^2\right) y\\
  \end{cases}
\end{align*}

A forma matricial do sistema acima é $\dot{\mathbf{X}} = \mathbf{A} \mathbf{X}$, em que:

$$
\mathbf{X} = 
\begin{bmatrix}
  x\\
  y
\end{bmatrix}
$$

e 

$$
\mathbf{A} = 
\begin{bmatrix}
  0 & 1\\
  -1 & \mu
\end{bmatrix}
$$


## Desenho do Campo de Direções

```{r}
# Bibliotecas necessárias
library(dplyr)
library(ggplot2)
library(grid)
library(gganimate)
```




## Método de Runge-kutta de ordem 4

```{r}
# Funções auxiliares

## Funções do Campo de Direções da EDO
dxdt <- function(x, y, mu=0.2) {
  return(y)
}

dydt <- function(x, y, mu=0.2) {
  return(-x+mu*(1-x^2)*y)
}

## Método de Runge-Kutta de Ordem 4
RK4 <- function(x0, y0, t0=0, t1=10, N=101, mu=0.2) {
  h = (t1-t0)/(N-1)
  t = c(t0)
  x = c(x0)
  y = c(y0)
  for (i in 2:(N+1)) {
    k1 = h * dxdt(x[i-1], y[i-1], mu=mu)
    l1 = h * dydt(x[i-1], y[i-1], mu=mu)
    
    k2 = h * dxdt(x[i-1] + k1/2, y[i-1] + l1/2, mu=mu)
    l2 = h * dydt(x[i-1] + k1/2, y[i-1] + l1/2, mu=mu)
    
    k3 = h * dxdt(x[i-1] + k2/2, y[i-1] + l2/2, mu=mu)
    l3 = h * dydt(x[i-1] + k2/2, y[i-1] + l2/2, mu=mu)
    
    k4 = h * dxdt(x[i-1], y[i-1], mu=mu)
    l4 = h * dydt(x[i-1], y[i-1], mu=mu)
    
    k = (k1+2*k2+2*k3+k4)/6
    l = (l1+2*l2+2*l3+l4)/6
    
    t = append(t, t[i-1]+h)
    x = append(x, x[i-1]+k)
    y = append(y, y[i-1]+l)
  }
  df = data.frame(t=t, x=x, y=y)
  return(df)
} 




## Função para obtenção dos dados do campo de direções
get_direction_field <- function(x.grid, y.grid, mu=0.2) {
  pos_x <- c()
  pos_y <- c()
  vel_x <- c()
  vel_y <- c()

  for (xi in x.grid){
    for (yi in y.grid){
      dx = dxdt(xi, yi, mu=mu)
      dy = dydt(xi, yi, mu=mu)
      L <- 4*sqrt(dx^2 + dy^2)
      if (L != 0) {
        dx <- dx/(L)
        dy <- dy/(L)
        pos_x <- append(pos_x, xi)
        pos_y <- append(pos_y, yi)
        vel_x <- append(vel_x, dx)
        vel_y <- append(vel_y, dy)      
      }
  
    }
  }
  
  grid_df <- data.frame(x=pos_x, y=pos_y, dx=vel_x, dy=vel_y)
  return(grid_df)

}

```



```{r, fig.align='center'}

mu <- 0.5
x.grid <- seq(from=-4, to=4, by=0.5)
y.grid <- seq(from=-4, to=4, by=0.5)
grid_df = get_direction_field(x.grid, y.grid, mu=mu)

rk4_df <- RK4(x0=-3, y0=2, t0=0, t1=20,  N=101, mu=mu)
rk4_df$x_end <- c(rk4_df$x[-1], NA)
rk4_df$y_end <- c(rk4_df$y[-1], NA)
rk4_df <- rk4_df[!is.na(rk4_df$x_end),]

head(rk4_df)


p <- ggplot(data=rk4_df, aes(x=x, y=y)) +
  geom_segment(aes(xend=x_end, yend=y_end), color="steelblue") +
  #geom_segment(data=grid_df, aes(x=x, y=y, xend=x+dx, yend=y+dy), arrow=arrow(length=unit(0.1, "cm")), colour="gray") + 
  labs(
    title="Solução da Equação de Van der Pol",
    x=expression(V),
    y=expression(dot(V))
  ) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) + 
  transition_reveal(t)
```


```{r}
animate(p, nframes = 10)
```




















